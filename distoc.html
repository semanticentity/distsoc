<!DOCTYPE html>
<html>

<head>
  <title>Distsoc: Distributed Separation of Concerns</title>
  <style>
    /* --- Basic Styles --- */
    body { margin: 0; overflow: hidden; background: #111827; font-family: monospace; }
    canvas { display: block; }
    #ui { position: fixed; top: 10px; left: 10px; color: #E5E7EB; z-index: 1000; }
    #focus-meter { width: 200px; height: 20px; background: #1F2937; border-radius: 10px; overflow: hidden; margin-bottom: 10px; }
    #focus-bar { height: 100%; width: 100%; background: #10B981; transition: width 0.3s, background-color 0.3s; } /* Added background-color transition */
    .stats { background: #374151; padding: 8px; border-radius: 4px; margin-bottom: 5px; }

    /* --- Terminal Styles --- */
    #terminal {
      position: fixed;
      top: 40px;
      left: 10px;
      background: rgba(31, 41, 55, 0.95);
      color: #F9FAFB;
      border: 2px solid #312e81;
      border-radius: 6px;
      font-size: 14px;
      width: 350px;
      min-width: 220px;
      max-width: 90vw;
      min-height: 120px;
      max-height: 70vh;
      height: 250px;
      display: none;
      z-index: 1001; 
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
      resize: none;
      position: relative;
      overflow: hidden;
      padding: 10px;
    }
    #terminal.show {
      display: block !important;
    }
    #terminal-log {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      bottom: 48px; /* 38px input height + 10px padding */
      margin: 0;
      white-space: pre-wrap;
      overflow-y: auto;
      background: none;
      transition: none;
      box-sizing: border-box;
      padding: 0;
    }
    #terminal-input-line {
      position: absolute;
      left: 10px;
      right: 10px;
      bottom: 10px;
      height: 38px;
      display: flex;
      align-items: center;
      background: none;
      border-top: 1px solid rgba(75, 85, 99, 0.3);
      z-index: 2;
      padding: 8px 0 0 0;
      margin: 0;
    }
    #terminal-resize-handle {
      position: absolute;
      width: 18px;
      height: 18px;
      right: 2px;
      bottom: 2px;
      cursor: se-resize;
      z-index: 10;
      background: linear-gradient(135deg, #312e81 40%, #9ca3af 100%);
      border-radius: 3px;
      opacity: 0.6;
      transition: opacity 0.2s;
    }
    #terminal-resize-handle:hover {
      opacity: 1;
    }
    #terminal pre { margin: 0; white-space: pre-wrap; overflow-y: auto; scrollbar-width: thin; scrollbar-color: #4B5563 #1F2937; }
    #terminal pre::-webkit-scrollbar { width: 8px; }
    #terminal pre::-webkit-scrollbar-track { background: #1F2937; border-radius: 4px; }
    #terminal pre::-webkit-scrollbar-thumb { background-color: #4B5563; border-radius: 4px; border: 2px solid #1F2937; }
    #terminal-input-line { display: flex; align-items: center; }
    #terminal-input-line span { margin-right: 5px; color: #6EE7B7; }
    #terminal input { background: transparent; border: none; color: #F9FAFB; font-family: monospace; font-size: 14px; outline: none; flex-grow: 1; width: auto; }
    .success { color: #10B981; } .warn { color: #FBBF24; } .error { color: #EF4444; } .info { color: #3B82F6; } .input { color: #9CA3AF; } .system { color: #A78BFA; }

    /* --- Building Info Box Styles --- */
    #building-info {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: rgba(31, 41, 55, 0.9);
        color: #E5E7EB;
        border: 1px solid #4B5563;
        border-radius: 8px;
        padding: 15px;
        max-width: 280px;
        font-size: 13px;
        z-index: 1002;
        display: none;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(3px);
    }
    #building-info h3 { margin: 0 0 8px 0; color: #A78BFA; font-size: 16px; border-bottom: 1px solid #4B5563; padding-bottom: 5px; }
    #building-info p { margin: 5px 0; line-height: 1.4; }
    #building-info strong { color: #9CA3AF; margin-right: 5px; }
    #building-info ul { list-style: none; padding: 0; margin: 8px 0 0 0; }
    #building-info li { background: #374151; padding: 3px 6px; margin-bottom: 4px; border-radius: 4px; font-size: 12px; }
    #building-info .close-btn { position: absolute; top: 5px; right: 8px; background: none; border: none; color: #9CA3AF; font-size: 18px; cursor: pointer; padding: 0; line-height: 1; }
    #building-info .close-btn:hover { color: #E5E7EB; }

    /* --- Mode Selector Styles --- */
    /* --- Mode Selector Styles --- */
    #mode-selector { margin-top: 10px; display: flex; align-items: center; }
    #mode-selector span { margin-right: 10px; color: #A78BFA; }
    .mode-btn { 
      background: rgba(31, 41, 55, 0.7); 
      border: 1px solid #4B5563; 
      padding: 5px 12px; 
      font-size: 14px; 
      cursor: pointer; 
      color: #E5E7EB; 
      margin-right: 5px;
      border-radius: 4px;
      transition: all 0.2s ease;
    }
    .mode-btn:hover { background: rgba(31, 41, 55, 0.9); border-color: #6B7280; }
    .mode-btn.active { 
      background: linear-gradient(135deg, #312e81 0%, #4F46E5 100%); 
      color: #F9FAFB; 
      border-color: #6366F1; 
      box-shadow: 0 0 8px rgba(99, 102, 241, 0.6);
    }
    
    /* --- Tooltip Styles --- */
    .tooltip {
      position: relative;
      display: inline-block;
    }
    .tooltip .tooltiptext {
      visibility: hidden;
      background-color: rgba(31, 41, 55, 0.95);
      color: #F9FAFB;
      text-align: center;
      border-radius: 6px;
      padding: 8px 12px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      transition: opacity 0.3s;
      font-size: 12px;
      width: 200px;
      border: 1px solid #4B5563;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      pointer-events: none;
    }
    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }
    
    /* --- Node Tooltip Styles --- */
    .node-tooltip {
      background-color: rgba(31, 41, 55, 0.95);
      color: #F9FAFB;
      border-radius: 6px;
      padding: 10px 14px;
      font-size: 13px;
      max-width: 250px;
      border: 1px solid #6366F1;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5), 0 0 8px rgba(99, 102, 241, 0.4);
      backdrop-filter: blur(3px);
      line-height: 1.4;
      text-align: left;
    }
  </style>
</head>

<body>
  <canvas id="gameCanvas"></canvas>
  <div id="ui">
    <div id="focus-meter"><div id="focus-bar"></div></div>
    <div id="stats" class="stats"></div>
    <div id="mode-selector" class="stats">
      <span>Mode: </span>
      <div class="tooltip">
        <button id="sandbox-mode" class="mode-btn active">Sandbox</button>
        <span class="tooltiptext">Learn at your own pace without time pressure. Explore nodes and connections with helpful guidance.</span>
      </div>
      <div class="tooltip">
        <button id="challenge-mode" class="mode-btn">Challenge</button>
        <span class="tooltiptext">Complete timed tasks to earn points. Each attempt gives you 2 minutes to build the required connections.</span>
      </div>
    </div>
    <div id="game-stats" class="stats" style="display: none;">
      <div id="score">Score: 0</div>
      <div id="task-timer">Time: 2:00</div>
      <div id="tasks-completed">Tasks: 0</div>
    </div>
    <div id="terminal" class="">
      <pre id="terminal-log"></pre>
      <div id="terminal-input-line">
        <span>&gt;</span><input type="text" id="terminal-input" spellcheck="false" />
      </div>
      <div id="terminal-resize-handle"></div>
    </div>
    <div id="building-info">
        <button class="close-btn" onclick="hideBuildingInfo()">×</button>
        <h3 id="info-name">Building Name</h3>
        <p id="info-type"><strong>Type:</strong> </p>
        <p id="info-desc"><strong>Desc:</strong> </p>
        <p><strong>Tools:</strong></p>
        <ul id="info-tools"></ul>
        <p id="info-connections"><strong>Input:</strong> | <strong>Output:</strong> </p>
        <p id="info-status"><strong>Status:</strong> </p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const focusBar = document.getElementById('focus-bar');
    const stats = document.getElementById('stats');
    const terminal = document.getElementById('terminal');
    const terminalLog = document.getElementById('terminal-log');
    const terminalInput = document.getElementById('terminal-input');
    const buildingInfoBox = document.getElementById('building-info');

    let terminalActive = false;
    let terminalCooldown = false;
    let currentNode = null;
    let commandHistory = [];
    let historyIndex = -1;
    const knownCommands = ['help', 'clear', 'status', 'list tools', 'run sanitize', 'send', 'run', 'exit', 'scan network', 'lock']; // Added lock command

    // --- Enhancement State ---
    let networkScanActive = false;
    // --- Building Data Definitions ---
    const BUILDING_DEFAULTS = {
        'home': { name: "Home Base", description: "Your central hub. Connects to other nodes and recharges focus.", tools: ["diagnostic_suite", "focus_recharge"], connections: { input: [], output: ["code", "data", "etl"] }, color: '#6366F1' },
        'code': { name: "Code Workshop", description: "Creates and improves code for your network.", tools: ["compile", "lint", "refactor"], connections: { input: ["home", "data"], output: ["data", "etl"] }, color: '#10B981' },
        'data': { name: "Data Center", description: "Stores and organizes information for your network.", tools: ["parse", "validate", "transform"], connections: { input: ["home", "code", "etl"], output: ["code", "storage"] }, color: '#F59E0B' },
        'etl': { name: "Transfer Station", description: "Moves and transforms data between different nodes.", tools: ["extract", "route", "load_balance"], connections: { input: ["code", "data"], output: ["data", "storage", "home"] }, color: '#EC4899' },
        'storage': { name: "Storage Vault", description: "Safely stores data for long-term use.", tools: ["archive", "retrieve", "checksum"], connections: { input: ["data", "etl"], output: [] }, color: '#8B5CF6' }
    };
    const ALL_BUILDING_TYPES = Object.keys(BUILDING_DEFAULTS);
    const colors = { // Keep colors definition consistent
        background: '#111827', player: '#10B981', safezone: '#059669', home: '#6366F1',
        text: '#E5E7EB', accent: '#F59E0B', pet1: '#EC4899', pet2: '#8B5CF6',
        network: '#3B82F6', data: '#F59E0B', code: '#10B981',
    };

    // --- Particle System Class ---
    class ParticleSystem {
      constructor() {
        this.particles = [];
      }
      emit(x, y, color, speed = 2, count = 5, sizeRange = [2, 6], life = 1) {
        for (let i = 0; i < count; i++) {
          this.particles.push({
            x, y, color,
            size: Math.random() * (sizeRange[1] - sizeRange[0]) + sizeRange[0],
            vx: (Math.random() - 0.5) * speed * 2,
            vy: (Math.random() - 0.5) * speed * 2,
            life: life * (Math.random() * 0.5 + 0.5)
          });
        }
      }
      update() { // *** THIS METHOD IS CRUCIAL ***
        this.particles = this.particles.filter(p => {
          p.x += p.vx;
          p.y += p.vy;
          p.vx *= 0.98;
          p.vy *= 0.98;
          p.life -= 0.02;
          return p.life > 0;
        });
      }
      draw(ctx) {
        this.particles.forEach(p => {
          ctx.save();
          ctx.globalAlpha = Math.max(0, p.life);
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.rect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
          ctx.fill();
          ctx.restore();
        });
      }
    }

    // --- Game Object ---
    const game = {
      // Camera system for panning and zooming
      camera: {
        x: 0,
        y: 0,
        zoom: 1,
        minZoom: 0.5,
        maxZoom: 2,
        followPlayer: true,
        panSpeed: 10,
        // Convert world coordinates to screen coordinates
        worldToScreen: function(worldX, worldY) {
          return {
            x: (worldX - this.x) * this.zoom + canvas.width / 2,
            y: (worldY - this.y) * this.zoom + canvas.height / 2
          };
        },
        // Convert screen coordinates to world coordinates
        screenToWorld: function(screenX, screenY) {
          return {
            x: (screenX - canvas.width / 2) / this.zoom + this.x,
            y: (screenY - canvas.height / 2) / this.zoom + this.y
          };
        },
        // Update camera position to follow player
        update: function() {
          if (this.followPlayer) {
            // Smooth camera movement towards player
            this.x += (game.player.x - this.x) * 0.1;
            this.y += (game.player.y - this.y) * 0.1;
          }
        }
      },
      player: { x: 400, y: 300, size: 25, speed: 4, focus: 100, maxFocus: 100, rotation: 0 },
      pets: [
        { x: 350, y: 300, size: 12, color: colors.pet1, targetOffset: { x: -40, y: -15 }, rotation: 0, lerpFactor: 0.1 },
        { x: 450, y: 300, size: 12, color: colors.pet2, targetOffset: { x: -40, y: 15 }, rotation: 0, lerpFactor: 0.08 }
      ],
      buildings: [],
      particles: new ParticleSystem(), // Create instance AFTER class definition
      keys: {},
      isMovingPlayer: false,
      // Game progression tracking
      score: 0,
      completedTasks: 0,
      currentTask: null,
      taskStartTime: 0,
      taskTimeLimit: 120, // seconds
      connections: [], // Track active connections between nodes
      // Game mode
      mode: 'sandbox', // 'sandbox' or 'challenge'
      sandboxSteps: [
        { message: "Welcome to Sandbox Mode! Let's learn the basics.", type: 'welcome' },
        { message: "First, move around using the arrow keys or double-click on a node.", type: 'movement' },
        { message: "Now, approach a node and press 'E' to connect to it.", type: 'connect' },
        { message: "Type 'help' to see available commands.", type: 'help' },
        { message: "Try 'list tools' to see what tools this node has.", type: 'tools' },
        { message: "Now try 'send [node_type]' to connect to another node.", type: 'send' },
        { message: "Great! You've created your first connection. Try connecting more nodes.", type: 'connection' },
        { message: "When you're ready for a challenge, click 'Challenge Mode' at the top.", type: 'complete' }
      ],
      currentSandboxStep: 0
    };


    // --- Enhanced Terminal Functions ---
    function typeLine(text, opts = {}) {
      const { delay = 15, className = '', onDone = () => {} } = opts;
      let i = 0;
      const line = document.createElement('div');
      if (className) line.classList.add(className);
      terminalLog.appendChild(line);

      function step() {
        if (i < text.length) {
          line.textContent += text[i++];
          terminalLog.scrollTop = terminalLog.scrollHeight;
          setTimeout(step, delay);
        } else {
          // After output, always scroll to bottom
          setTimeout(() => {
            terminalLog.scrollTop = terminalLog.scrollHeight;
          }, 0);
          onDone();
        }
      }
      step();
    }

    // Function to show a special locked terminal view for locked nodes
    function showLockedTerminal(building) {
      // Don't set currentNode since we're not actually connected
      terminalLog.innerHTML = '';
      terminal.classList.add('show');
      terminalActive = true;
      showBuildingInfo(building); // Auto open info panel for this node
      
      // Change terminal border color to red to indicate locked status
      const originalBorder = terminal.style.border;
      terminal.style.border = '2px solid #EF4444';
      
      // Fallback: Focus input immediately, even before typeLine finishes
      setTimeout(() => { terminalInput.focus(); }, 10);
      
      // Show locked terminal interface
      typeLine(`>> Attempting connection to ${building.name} (${building.type.toUpperCase()}) node [${building.x}, ${building.y}]...`, { className: 'info' });
      setTimeout(() => {
          typeLine(`>> ACCESS DENIED: Node is locked.`, { className: 'error' });
          setTimeout(() => {
              typeLine(`>> Security protocol active. Authentication required.`, { className: 'warn' });
              setTimeout(() => {
                  typeLine(`>> Enter credentials to unlock (format: 'auth username password'):`, { className: 'system' });
                  
                  // Override the handleCommand function temporarily for this terminal session
                  const originalHandleCommand = handleCommand;
                  handleCommand = function(cmd) {
                      typeLine(`> ${cmd}`, { className: 'input', delay: 1 });
                      
                      const args = cmd.toLowerCase().split(' ');
                      if (args[0] === 'auth' && args.length >= 3) {
                          const username = args[1];
                          const password = args[2];
                          
                          // Check if credentials are valid (custom password or default 'unlock')
                          const correctPassword = building.unlockPassword || 'unlock';
                          if (password === correctPassword) {
                              typeLine(`>> Authentication successful. Welcome, ${username}.`, { className: 'success' });
                              setTimeout(() => {
                                  // Unlock the node
                                  building.locked = false;
                                  
                                  // Visual feedback for unlocking
                                  game.particles.emit(building.x + building.width/2, 
                                                      building.y + building.height/2, 
                                                      '#10B981', 10, 20, [3, 6], 1.5);
                                  
                                  // Reset terminal border
                                  terminal.style.border = originalBorder;
                                  
                                  // Reset handleCommand and show normal terminal
                                  handleCommand = originalHandleCommand;
                                  hideTerminal();
                                  setTimeout(() => {
                                      showTerminal(building);
                                  }, 500);
                              }, 1000);
                          } else {
                              typeLine(`>> Authentication failed. Invalid credentials.`, { className: 'error' });
                          }
                      } else if (args[0] === 'exit') {
                          typeLine(`>> Disconnecting...`, { className: 'warn' });
                          setTimeout(() => {
                              // Reset terminal border and handleCommand
                              terminal.style.border = originalBorder;
                              handleCommand = originalHandleCommand;
                              hideTerminal();
                          }, 500);
                      } else {
                          typeLine(`>> Command not recognized. Use 'auth username password' to authenticate or 'exit' to disconnect.`, { className: 'warn' });
                      }
                      
                      // Focus the input
                      setTimeout(() => { terminalInput.focus(); }, 10);
                  };
              }, 800);
          }, 800);
      }, 800);
    }
    
    function showTerminal(building) {
      currentNode = building;
      terminalLog.innerHTML = '';
      terminal.classList.add('show');
      terminalActive = true;
      showBuildingInfo(building); // Auto open info panel for this node

      // Fallback: Focus input immediately, even before typeLine finishes
      setTimeout(() => { terminalInput.focus(); }, 10);

      typeLine(`>> Establishing connection to ${building.name} (${building.type.toUpperCase()}) node [${building.x}, ${building.y}]...`, { className: 'info' });
      setTimeout(() => {
          typeLine(`>> Secure channel established.`, { className: 'success' });
          
          // In sandbox mode, provide extra information about the node
          if (game.mode === 'sandbox') {
            // Show node-specific information
            const nodeType = building.type;
            let nodeInfo = '';
            
            switch(nodeType) {
              case 'home':
                nodeInfo = `This is a ${building.name}, the central hub of your network. It can connect to code, data, and ETL nodes.`;
                break;
              case 'code':
                nodeInfo = `This is a ${building.name}, used for processing code. It can receive from home/data nodes and send to data/ETL nodes.`;
                break;
              case 'data':
                nodeInfo = `This is a ${building.name}, used for data processing. It has versatile connections to most other node types.`;
                break;
              case 'etl':
                nodeInfo = `This is a ${building.name}, used for data transformation. It can connect to data, storage, and home nodes.`;
                break;
              case 'storage':
                nodeInfo = `This is a ${building.name}, used for data storage. It can receive from data and ETL nodes but doesn't send data out.`;
                break;
              default:
                nodeInfo = `This is a ${building.name}. Explore its connections using commands.`;
            }
            
            // Show the info with a slight delay
            setTimeout(() => {
              typeLine(`>> ${nodeInfo}`, { className: 'info' });
              typeLine(`>> Input connections: ${building.connections?.input?.join(', ') || 'none'}`, { className: 'info' });
              typeLine(`>> Output connections: ${building.connections?.output?.join(', ') || 'none'}`, { className: 'info' });
            }, 300);
          }
          
          typeLine(`Status: ONLINE. Type 'help' for commands.`, { className: 'system' }, () => {
              terminalInput.value = '';
              terminalInput.focus(); // Always focus terminal input
          });
      }, 400);
    }

    function hideTerminal() {
      terminal.classList.remove('show');
      terminalActive = false;
      currentNode = null;
      // canvas.focus(); // Optionally refocus canvas
    }

    // --- Autopilot Script Example ---
     const scripts = {
        init: [
            { delay: 0, action: () => typeLine('>> AUTOPILOT: Running initialization sequence...', { className: 'system' }) },
            { delay: 500, action: () => handleCommand('status', currentNode) },
            { delay: 1500, action: () => handleCommand('list tools', currentNode) },
            { delay: 2500, action: () => typeLine('>> AUTOPILOT: Initialization complete.', { className: 'system' }, () => { terminalInput.disabled = false; terminalInput.focus(); }) }, // Re-enable here
        ]
    };

    function runScript(name) {
        const steps = scripts[name];
        if (!steps || !currentNode) { // Ensure node context
            typeLine(`>> ERROR: Script "${name}" not found or no node connected.`, { className: 'error' });
            terminalInput.disabled = false; // Re-enable if script fails early
            return;
        }

        let i = 0;
        let cumulativeDelay = 0; // To re-enable input reliably

        function executeStep() {
            if (i < steps.length) {
                const step = steps[i];
                const stepDelay = step.delay || 0;
                cumulativeDelay += stepDelay;

                setTimeout(() => {
                    if (!terminalActive) return; // Stop script if terminal closed mid-run
                    try {
                         step.action();
                    } catch (error) {
                        console.error("Error during script step:", error);
                        typeLine(`>> SCRIPT ERROR: ${error.message}`, { className: 'error' });
                        terminalInput.disabled = false; // Stop and re-enable on error
                        terminalInput.focus();
                        return; // Stop execution
                    }
                    i++;
                    // Immediately schedule the next step; delay is handled by setTimeout
                    if (terminalActive) { // Check again before scheduling next
                        executeStep();
                    } else { // Terminal was closed
                         terminalInput.disabled = false;
                    }
                }, stepDelay);
            } else {
                // Script finished - re-enable input if last step didn't
                setTimeout(() => {
                    if (terminalActive) {
                         terminalInput.disabled = false;
                         terminalInput.focus();
                    }
                }, 100); // Small buffer after last step completes
            }
        }
        terminalInput.disabled = true; // Disable input during script run
        executeStep();
    }


    // --- Command Handling Logic ---
    function handleCommand(cmd, node) { // node parameter is important!
        const fullCmdText = cmd; // Keep original for history if needed
        typeLine(`> ${fullCmdText}`, { className: 'input', delay: 1 });
        
        // Add to command history for sandbox mode progression tracking
        commandHistory.push(fullCmdText);

        if (!node && !['exit', 'scan', 'help', 'clear'].includes(cmd.toLowerCase().split(' ')[0])) { // Allow some global commands
            typeLine(">> CRITICAL ERROR: No node connection required for this command.", { className: 'error' });
            terminalInput.focus(); // Keep focus for retry
            return;
        }

        const args = cmd.toLowerCase().split(' ');
        const command = args[0];

        switch (command) {
            case 'help':
                typeLine("Available commands:", { className: 'info' });
                knownCommands.forEach((c, index) => typeLine(`  - ${c}`, { delay: 5, onDone: index === knownCommands.length - 1 ? () => terminalInput.focus() : ()=>{} }));
                break;
            case 'clear':
                terminalLog.innerHTML = '';
                if (node) typeLine(`>> Terminal cleared for ${node.name} (${node.type.toUpperCase()}).`, { className: 'system' }, () => terminalInput.focus());
                else typeLine(`>> Terminal cleared.`, { className: 'system' }, () => terminalInput.focus());
                break;
            case 'status':
                if (!node) { typeLine(">> ERROR: Connect to a node first ('e' key near node).", { className: 'error' }, () => terminalInput.focus()); break; }
                typeLine(`>> Node Name: ${node.name}`, { className: 'info' });
                typeLine(`>> Node Type: ${node.type.toUpperCase()}`, { className: 'info' });
                typeLine(`>> Location: [${node.x}, ${node.y}]`, { className: 'info' });
                typeLine(`>> Description: ${node.description}`, { className: 'info' });
                typeLine(`>> Integrity: 99.8%`, { className: 'info' }); // Placeholder
                typeLine(`>> Status: ONLINE ${node.locked ? '(LOCKED)' : ''}`, { className: node.locked ? 'warn' : 'success' }, () => terminalInput.focus());
                break;
            case 'list':
                 if (!node) { typeLine(">> ERROR: Connect to a node first.", { className: 'error' }, () => terminalInput.focus()); break; }
                 if (args[1] === 'tools') {
                    typeLine(">> Scanning node capabilities...", { className: 'info', delay: 10});
                    setTimeout(() => {
                        if (node.tools && node.tools.length > 0) {
                            node.tools.forEach(tool => typeLine(`  - ${tool}`, {className: 'success', delay: 5}));
                        } else {
                            typeLine("  No specific tools detected. Basic I/O available.", { className: 'warn' });
                        }
                        terminalInput.focus();
                    }, 500);
                 } else {
                     typeLine(">> Usage: list tools", { className: 'warn' }, () => terminalInput.focus());
                 }
              break;
           case 'run':
               if (!node) { typeLine(">> ERROR: Connect to a node first.", { className: 'error' }, () => terminalInput.focus()); break; }
               const scriptOrTool = args[1];
               if (!scriptOrTool) {
                    typeLine(">> Usage: run <tool_name | script_name>", { className: 'warn' }, () => terminalInput.focus()); break;
               }
               if (scriptOrTool === 'sanitize') { // Built-in 'tool' example
                    typeLine(">> Initializing node integrity scan...", { className: 'warn', delay: 15 });
                    setTimeout(() => typeLine(">> [||||||||||||||||||||] Scan complete.", { className: 'info' }), 1200);
                    setTimeout(() => typeLine(">> No anomalies detected. Node secure.", { className: 'success' }, ()=> terminalInput.focus()), 1800);
               } else if (scripts[scriptOrTool]) { // Check if it's a known script
                    runScript(scriptOrTool); // Pass the correct context
               } else if (node.tools && node.tools.includes(scriptOrTool)) { // Check if it's a tool on the node
                   typeLine(`>> Executing tool: ${scriptOrTool}...`, { className: 'system' });
                   setTimeout(() => typeLine(`>> Tool ${scriptOrTool} finished successfully.`, { className: 'success' }, ()=> terminalInput.focus()), 1500);
                   // Later: Add actual game logic effect of the tool
               } else {
                   typeLine(`>> ERROR: Unknown command, tool or script: "run ${scriptOrTool}"`, { className: 'error' }, () => terminalInput.focus());
               }
               break;
           case 'send':
          if (!node) { typeLine(">> ERROR: Connect to a node first.", { className: 'error' }, () => terminalInput.focus()); break; }
          const targetType = args[1];
          if (!targetType) {
              typeLine(">> Usage: send <target_type>", { className: 'warn' }, () => terminalInput.focus());
              break;
          }

          if (!node.connections?.output?.includes(targetType)) {
              typeLine(`>> ERROR: Node ${node.name} cannot send output to ${targetType}.`, { className: 'error' }, () => terminalInput.focus());
              break;
          }

          // Find a target node of the right type
          const targetNodes = game.buildings.filter(b => b.type === targetType && !b.locked);
          if (targetNodes.length === 0) {
              typeLine(`>> ERROR: No available ${targetType} nodes found.`, { className: 'error' }, () => terminalInput.focus());
              break;
          }

          // Activate both nodes
          node.active = true;
          const targetNode = targetNodes[0]; // Just use the first one for now
          targetNode.active = true;

          // Create connection and store it
          const newConnection = {
              from: node,
              to: targetNode,
              established: Date.now()
          };
          
          // Check if this connection already exists
          const existingConnection = game.connections.find(c => 
              (c.from === node && c.to === targetNode) || 
              (c.from === targetNode && c.to === node));
              
          if (!existingConnection) {
              game.connections.push(newConnection);
          }

          // Visual feedback
          typeLine(`>> Establishing connection to ${targetNode.name}...`, { className: 'info' });
          setTimeout(() => {
              typeLine(`>> Connection established: ${node.name} → ${targetNode.name}`, { className: 'success' }, () => {
                  // Check if this connection completes the current task
                  checkTaskCompletion();
                  terminalInput.focus();
              });
              
              // Emit particles along the connection path
              const startX = node.x + node.width/2;
              const startY = node.y + node.height/2;
              const endX = targetNode.x + targetNode.width/2;
              const endY = targetNode.y + targetNode.height/2;
              
              // Emit particles along the path
              const steps = 10;
              for (let i = 0; i < steps; i++) {
                  const t = i / steps;
                  const x = startX + (endX - startX) * t;
                  const y = startY + (endY - startY) * t;
                  setTimeout(() => {
                      game.particles.emit(x, y, colors.network, 2, 5, [2, 5], 0.8);
                  }, i * 80);
              }
          }, 800);
          break;
           case 'scan':
                if (args[1] === 'network') {
                    typeLine(">> Scanning network for available nodes...", { className: 'info' });
                    
                    // Activate network scan visual effect
                    networkScanActive = true;
                    setTimeout(() => { networkScanActive = false; }, 5000); // Show network connections for 5 seconds
                    
                    game.buildings.forEach((b, index) => {
                       setTimeout(() => {
                            // Check if this is the current node the player is connected to
                            const isCurrentNode = (node && b === node);
                            const nodeStatus = b.locked ? '-LOCKED-' : (isCurrentNode ? '★ CONNECTED ★' : '');
                            
                            // Use special highlighting for current node
                            const className = b.locked ? 'warn' : (isCurrentNode ? 'success' : 'system');
                            
                            typeLine(`  [${index}] ${b.name} (${b.type.toUpperCase()}) @ [${b.x}, ${b.y}] ${nodeStatus}`, 
                                    { className: className, delay: 5});
                            
                            // If this is the current node, add a visual pulse effect to it
                            if (isCurrentNode) {
                                // Create a pulse effect at the node location
                                for (let i = 0; i < 8; i++) {
                                    setTimeout(() => {
                                        game.particles.emit(b.x + b.width/2, b.y + b.height/2, 
                                                          '#10B981', 5, 10, [3, 6], 0.8);
                                    }, i * 100);
                                }
                            }
                       }, index * 60); // Slightly slower stagger
                    });
                    
                    setTimeout(() => terminalInput.focus(), game.buildings.length * 60 + 150);
                } else {
                    typeLine(">> Usage: scan network", { className: 'warn' }, () => terminalInput.focus());
                }
                break;
          case 'exit':
              typeLine(">> Disconnecting...", { className: 'warn' });
              setTimeout(hideTerminal, 500);
              break;
          case 'lock':
              if (!node) { typeLine(">> ERROR: Connect to a node first.", { className: 'error' }, () => terminalInput.focus()); break; }
              
              // Check if node is already locked
              if (node.locked) {
                  typeLine(">> Node is already locked.", { className: 'warn' }, () => terminalInput.focus());
                  break;
              }
              
              typeLine(">> Enter password to lock this node (format: 'confirm password'):", { className: 'system' });
              
              // Create a temporary command handler for the confirmation
              const originalHandler = handleCommand;
              handleCommand = function(confirmCmd) {
                  typeLine(`> ${confirmCmd}`, { className: 'input', delay: 1 });
                  
                  const confirmArgs = confirmCmd.toLowerCase().split(' ');
                  if (confirmArgs[0] === 'confirm' && confirmArgs.length >= 2) {
                      const password = confirmArgs[1];
                      
                      // Store the password (in a real system, you'd hash this)
                      node.unlockPassword = password;
                      node.locked = true;
                      
                      typeLine(">> Node successfully locked. Password set.", { className: 'success' });
                      setTimeout(() => {
                          // Visual feedback for locking
                          game.particles.emit(node.x + node.width/2, 
                                            node.y + node.height/2, 
                                            '#EF4444', 5, 10, [2, 4], 1.2);
                          
                          // Reset command handler and disconnect
                          handleCommand = originalHandler;
                          typeLine(">> Disconnecting from locked node...", { className: 'warn' });
                          setTimeout(() => {
                              hideTerminal();
                          }, 800);
                      }, 1000);
                  } else if (confirmArgs[0] === 'cancel') {
                      typeLine(">> Lock operation cancelled.", { className: 'info' });
                      handleCommand = originalHandler;
                      terminalInput.focus();
                  } else {
                      typeLine(">> Invalid format. Use 'confirm PASSWORD' to set lock password or 'cancel' to abort.", { className: 'warn' });
                      terminalInput.focus();
                  }
              };
              break;
          default:
              typeLine(`>> COMMAND UNRECOGNIZED: "${fullCmdText}"`, { className: 'error' }, () => terminalInput.focus());
              break;
      }
      // Ensure scroll after command output might finish later due to timeouts
      setTimeout(() => {if (terminalActive) terminalLog.scrollTop = terminalLog.scrollHeight}, 50);
    }


    // --- Terminal Input Event Listener ---
    terminalInput.addEventListener('keydown', (e) => {
        if (!terminalActive) return;

        if (e.key === 'Enter') {
            e.preventDefault();
            if (terminalInput.disabled) return; // Ignore if script is running
            const cmd = terminalInput.value.trim();
            if (cmd.length > 0) {
                terminalInput.value = '';
                commandHistory.unshift(cmd);
                if (commandHistory.length > 20) commandHistory.pop();
                historyIndex = -1;
                handleCommand(cmd, currentNode); // Pass current node context
            }
        } else if (e.key === 'ArrowUp') {
             if (terminalInput.disabled) return;
            e.preventDefault();
            if (commandHistory.length > 0 && historyIndex < commandHistory.length - 1) {
                historyIndex++;
                terminalInput.value = commandHistory[historyIndex];
                terminalInput.setSelectionRange(terminalInput.value.length, terminalInput.value.length);
            }
        } else if (e.key === 'ArrowDown') {
             if (terminalInput.disabled) return;
            e.preventDefault();
            if (historyIndex > 0) {
                historyIndex--;
                terminalInput.value = commandHistory[historyIndex];
                 terminalInput.setSelectionRange(terminalInput.value.length, terminalInput.value.length);
            } else {
                historyIndex = -1;
                terminalInput.value = '';
            }
        } else if (e.key === 'Tab') {
             if (terminalInput.disabled) return;
            e.preventDefault();
            const currentInput = terminalInput.value.trimStart();
            const partialCmd = currentInput.split(' ')[0].toLowerCase(); // Autocomplete only the command part
            if (partialCmd.length > 0) {
                const potentialCommands = knownCommands.filter(cmd => cmd.startsWith(partialCmd));
                if (potentialCommands.length === 1) { // Only complete if unique match
                     terminalInput.value = potentialCommands[0] + ' ';
                     terminalInput.setSelectionRange(terminalInput.value.length, terminalInput.value.length);
                } else if (potentialCommands.length > 1) {
                    // Optional: Log possible completions if multiple matches
                    typeLine(`>> Possible completions: ${potentialCommands.join(', ')}`, {className: 'info', delay: 1});
                }
            }
        } else if (e.key === 'Escape') {
             e.preventDefault();
             hideTerminal();
        }
    });


    // --- Building Generation ---
    function generateBuildings(count = 7) { // Defaulting to 7 as per setup
        const nodes = [];
        const placedPositions = [];
        const minDistance = 160; // *** REDUCED DISTANCE ***
        const padding = 40; // Padding from canvas edges

        // Ensure at least one 'home' node
        const homeDefaults = BUILDING_DEFAULTS['home'];
        // NOTE: Width/Height are now set by the old drawing logic, but we still need placement logic
        const tempWidth = 100 + Math.random() * 20; // Use for placement calculation only
        const tempHeight = 100 + Math.random() * 20;// Use for placement calculation only
        const homeX = Math.random() * (canvas.width - tempWidth - padding * 2) + padding;
        const homeY = Math.random() * (canvas.height - tempHeight - padding * 2) + padding;

        nodes.push({
            id: `node-0`, type: 'home',
            x: Math.floor(homeX), y: Math.floor(homeY),
            width: Math.floor(tempWidth), height: Math.floor(tempHeight), // Store dimensions for old logic
            radius: 120 + Math.random() * 30, // Regen radius still useful
            regen: 0.5 + Math.random() * 0.2,
            required: true, locked: false,
            ...homeDefaults
        });
        placedPositions.push({ x: nodes[0].x + nodes[0].width/2, y: nodes[0].y + nodes[0].height/2 }); // Store center point for distance check

        for (let i = 1; i < count; i++) {
            let type = ALL_BUILDING_TYPES[Math.floor(Math.random() * ALL_BUILDING_TYPES.length)];
            if (type === 'home' && Math.random() > 0.15) { // Lower chance of extra homes
                 let nonHomeTypes = ALL_BUILDING_TYPES.filter(t => t !== 'home');
                 type = nonHomeTypes[Math.floor(Math.random() * nonHomeTypes.length)];
            }

            const defaults = BUILDING_DEFAULTS[type];
            const width = 80 + Math.random() * 40; // Will be used by the old drawing logic
            const height = 80 + Math.random() * 40;// Will be used by the old drawing logic
            let x, y, centerX, centerY, tooClose;
            let attempts = 0;

            do {
                tooClose = false;
                x = Math.random() * (canvas.width - width - padding * 2) + padding;
                y = Math.random() * (canvas.height - height - padding * 2) + padding;
                centerX = x + width / 2; // Calculate center for distance check
                centerY = y + height / 2;

                for (const pos of placedPositions) {
                    if (Math.hypot(centerX - pos.x, centerY - pos.y) < minDistance) {
                        tooClose = true;
                        break;
                    }
                }
                attempts++;
            } while (tooClose && attempts < 100); // Increased attempts slightly

             if (attempts >= 100) console.warn("Could not place building far enough:", type);

            nodes.push({
                id: `node-${i}`, type: type,
                x: Math.floor(x), y: Math.floor(y),
                width: Math.floor(width), height: Math.floor(height), // Store dimensions
                radius: 90 + Math.random() * 40, // Regen radius still useful
                regen: 0.3 + Math.random() * 0.3,
                required: Math.random() < 0.1,
                locked: Math.random() < 0.2,
                ...defaults
            });
             placedPositions.push({ x: centerX, y: centerY }); // Store center point for distance check
        }
        // Buildings generated successfully
        return nodes;
    }

    // Tool descriptions for tooltips
    const TOOL_DESCRIPTIONS = {
        // Home tools
        'diagnostic_suite': 'Analyzes network health and identifies issues with connections.',
        'focus_recharge': 'Restores focus energy to continue operations.',
        
        // Code tools
        'compile': 'Transforms code into executable format for other nodes.',
        'lint': 'Checks code for errors and improves quality.',
        'refactor': 'Restructures code for better performance without changing behavior.',
        
        // Data tools
        'parse': 'Extracts meaningful information from raw data.',
        'validate': 'Ensures data meets required format and quality standards.',
        'transform': 'Converts data between different formats.',
        
        // ETL tools
        'extract': 'Pulls data from source systems for processing.',
        'route': 'Directs data flows between different nodes.',
        'load_balance': 'Distributes workloads evenly across the network.',
        
        // Storage tools
        'archive': 'Compresses and stores data for long-term retention.',
        'retrieve': 'Recovers stored data from archives.',
        'checksum': 'Verifies data integrity to prevent corruption.'
    };

    // --- Building Info Box Functions ---
    function showBuildingInfo(building) {
        if (!building) return;
        document.getElementById('info-name').textContent = building.name || "Unknown Node";
        document.getElementById('info-type').innerHTML = `<strong>Type:</strong> ${building.type.toUpperCase()}`;
        document.getElementById('info-desc').innerHTML = `<strong>Desc:</strong> ${building.description || "No data available."}`;
        
        const toolsList = document.getElementById('info-tools');
        toolsList.innerHTML = '';
        
        // Add tools with tooltips
        if (building.tools && building.tools.length) {
            building.tools.forEach(tool => {
                const li = document.createElement('li');
                li.className = 'tooltip';
                li.innerHTML = `${tool} <span class="tooltiptext">${TOOL_DESCRIPTIONS[tool] || 'No description available'}</span>`;
                toolsList.appendChild(li);
            });
        } else {
            const li = document.createElement('li');
            li.textContent = 'No tools available';
            toolsList.appendChild(li);
        }
        
        // Show connection info
        document.getElementById('info-connections').innerHTML = `<strong>Input:</strong> ${building.connections?.input?.join(', ') || 'none'} | <strong>Output:</strong> ${building.connections?.output?.join(', ') || 'none'}`;
        
        const statusText = building.locked ? 'LOCKED' : building.active ? 'ACTIVE' : building.processing ? 'PROCESSING' : 'IDLE';
        const statusColor = building.locked ? colors.accent : building.active ? colors.accent : building.processing ? colors.network : colors.player;
         document.getElementById('info-status').innerHTML = `<strong>Status:</strong> <span style="color:${statusColor}; font-weight: bold;">${statusText}</span>`;
        
        buildingInfoBox.style.display = 'block';
    }

    function hideBuildingInfo() {
        buildingInfoBox.style.display = 'none';
    }

    // --- Player Movement Function ---
    function movePlayerTo(targetX, targetY) {
      if (game.isMovingPlayer) return;
      game.isMovingPlayer = true;
      hideBuildingInfo(); // Hide info box when moving

      const startX = game.player.x;
      const startY = game.player.y;
      const dx = targetX - startX;
      const dy = targetY - startY;
      const distance = Math.hypot(dx, dy);
      const duration = Math.max(300, distance * 2.5); // Adjusted speed slightly
      let startTime = null;

      function step(timestamp) {
        if (!startTime) startTime = timestamp;
        const elapsed = timestamp - startTime;
        const progress = Math.min(1, elapsed / duration);

        // Ease out cubic interpolation for smoother arrival
        const easedProgress = 1 - Math.pow(1 - progress, 3);
        game.player.x = startX + dx * easedProgress;
        game.player.y = startY + dy * easedProgress;

        game.player.rotation = Math.atan2(dy, dx); // Point towards destination

        if (progress < 1) {
          requestAnimationFrame(step);
        } else {
          game.player.x = targetX;
          game.player.y = targetY;
          game.isMovingPlayer = false;
           // Potentially re-evaluate interaction after arrival?
           // e.g., check if near a node and auto-open info/terminal?
        }
      }
      requestAnimationFrame(step);
    }


    // --- Core Game Logic & Setup ---
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      // Regenerate buildings on resize? Might be disruptive, or helpful if layout breaks badly.
      // game.buildings = generateBuildings(7); // Uncomment if you want regeneration on resize
    }
    window.addEventListener('resize', resize);

    window.addEventListener('keydown', (e) => {
        const key = e.key.toLowerCase();
        if (key === 'escape' && terminalActive) {
             hideTerminal();
             game.keys['escape'] = false; // Consume escape
             return;
        }
        // --- Terminal Focus Enhancement on 'E' ---
        if (key === 'e') {
            if (terminal.style.display === 'block') {
                // Terminal already open, just re-focus input
                terminalInput.focus();
            }
            // Otherwise, let the normal game logic open terminal (showTerminal)
            // and focus will be handled there
        }
        if (terminalActive || game.isMovingPlayer) return; // Block game input
        game.keys[key] = true;
    });
    window.addEventListener('keyup', (e) => {
        const key = e.key.toLowerCase();
        if (key !== 'escape') {
            game.keys[key] = false;
        } else {
            // Ensure escape is false if terminal wasn't open
            game.keys['escape'] = false;
        }
    });

    // --- Node Tooltip System ---
    const nodeTooltip = document.createElement('div');
    nodeTooltip.className = 'node-tooltip';
    nodeTooltip.style.display = 'none';
    nodeTooltip.style.position = 'absolute';
    nodeTooltip.style.zIndex = '1000';
    nodeTooltip.style.pointerEvents = 'none';
    document.body.appendChild(nodeTooltip);

    // --- Camera Controls ---
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    
    // Helper functions for IO tooltips
    function getCompatibleTypes(nodeType, connectionType) {
      // Define compatibility between different node types
      const compatibility = {
        'data_source': { input: [], output: ['processor', 'visualizer', 'storage'] },
        'processor': { input: ['data_source', 'processor'], output: ['processor', 'visualizer', 'storage'] },
        'visualizer': { input: ['data_source', 'processor'], output: [] },
        'storage': { input: ['data_source', 'processor'], output: ['processor', 'visualizer'] },
        'security': { input: ['data_source', 'processor', 'storage'], output: ['processor'] }
      };
      
      // Get friendly names for the compatible types
      const typeToName = {
        'data_source': 'Data Sources',
        'processor': 'Processors',
        'visualizer': 'Visualizers',
        'storage': 'Storage Nodes',
        'security': 'Security Nodes'
      };
      
      const compatibleTypes = compatibility[nodeType][connectionType] || [];
      if (compatibleTypes.length === 0) {
        return connectionType === 'input' ? 'No inputs accepted' : 'No outputs provided';
      }
      
      return compatibleTypes.map(type => typeToName[type]).join(', ');
    }
    
    function getOutputType(nodeType) {
      // Define what kind of data each node type outputs
      const outputTypes = {
        'data_source': 'Raw Data',
        'processor': 'Processed Data',
        'visualizer': 'Visual Feedback',
        'storage': 'Stored Data',
        'security': 'Security Tokens'
      };
      
      return outputTypes[nodeType] || 'Unknown';
    }
    
    // Add mouse wheel zoom control
    canvas.addEventListener('wheel', function(e) {
      e.preventDefault();
      
      // Get mouse position in world coordinates before zoom
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      const worldPos = game.camera.screenToWorld(mouseX, mouseY);
      
      // Adjust zoom level based on wheel direction
      const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1; // Zoom out or in
      game.camera.zoom = Math.max(game.camera.minZoom, 
                       Math.min(game.camera.maxZoom, 
                                game.camera.zoom * zoomFactor));
      
      // If zooming in, temporarily disable camera following
      if (e.deltaY < 0 && game.camera.followPlayer) {
        game.camera.followPlayer = false;
        
        // Show a message about camera controls
        const message = document.createElement('div');
        message.className = 'camera-message';
        message.textContent = 'Camera unlocked. Use middle mouse to pan, double-click to re-center.';
        message.style.position = 'absolute';
        message.style.top = '120px';
        message.style.left = '50%';
        message.style.transform = 'translateX(-50%)';
        message.style.backgroundColor = 'rgba(31, 41, 55, 0.8)';
        message.style.color = '#F9FAFB';
        message.style.padding = '8px 12px';
        message.style.borderRadius = '4px';
        message.style.zIndex = '1000';
        message.style.pointerEvents = 'none';
        document.body.appendChild(message);
        
        // Remove the message after 3 seconds
        setTimeout(() => {
          document.body.removeChild(message);
        }, 3000);
      }
    });
    
    // Add middle mouse button panning
    canvas.addEventListener('mousedown', function(e) {
      if (e.button === 1) { // Middle mouse button
        e.preventDefault();
        isDragging = true;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
        game.camera.followPlayer = false; // Disable camera following when panning
        canvas.style.cursor = 'grabbing';
      }
    });
    
    // Create IO tooltips container if it doesn't exist
    let ioTooltip = document.getElementById('io-tooltip');
    if (!ioTooltip) {
      ioTooltip = document.createElement('div');
      ioTooltip.id = 'io-tooltip';
      ioTooltip.style.position = 'absolute';
      ioTooltip.style.backgroundColor = 'rgba(31, 41, 55, 0.95)';
      ioTooltip.style.color = '#F9FAFB';
      ioTooltip.style.padding = '8px 12px';
      ioTooltip.style.borderRadius = '4px';
      ioTooltip.style.fontSize = '14px';
      ioTooltip.style.maxWidth = '250px';
      ioTooltip.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.5)';
      ioTooltip.style.zIndex = '1000';
      ioTooltip.style.display = 'none';
      ioTooltip.style.border = '2px solid #4B5563';
      document.body.appendChild(ioTooltip);
    }
    
    canvas.addEventListener('mousemove', function(e) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      
      // Handle panning if middle mouse is pressed
      if (isDragging) {
        const dx = e.clientX - lastMouseX;
        const dy = e.clientY - lastMouseY;
        
        // Move camera in the opposite direction of mouse movement
        game.camera.x -= dx / game.camera.zoom;
        game.camera.y -= dy / game.camera.zoom;
        
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
      }
      
      // Convert mouse position to world coordinates for building hover
      const worldPos = game.camera.screenToWorld(mouseX, mouseY);
      
      // Check if mouse is over a building using world coordinates
      let hoveredBuilding = null;
      let isOverInput = false;
      let isOverOutput = false;
      
      for (const b of game.buildings) {
        if (worldPos.x >= b.x && worldPos.x <= b.x + b.width &&
            worldPos.y >= b.y && worldPos.y <= b.y + b.height) {
          hoveredBuilding = b;
          
          // Check if hovering over input area (left 20% of building)
          if (worldPos.x <= b.x + (b.width * 0.2)) {
            isOverInput = true;
          }
          // Check if hovering over output area (right 20% of building)
          else if (worldPos.x >= b.x + (b.width * 0.8) && worldPos.y <= b.y + (b.height * 0.7)) {
            isOverOutput = true;
          }
          
          break;
        }
      }
      
      if (hoveredBuilding) {
        const nodeInfo = BUILDING_DEFAULTS[hoveredBuilding.type];
        
        if (isOverInput) {
          // Show input tooltip
          ioTooltip.innerHTML = `
            <div style="font-weight: bold; color: #60A5FA; margin-bottom: 5px;">Input Connection</div>
            <div style="margin-bottom: 8px;">Connect output from other nodes to this input to process data.</div>
            <div style="font-size: 12px; color: #9CA3AF;">Compatible with: ${getCompatibleTypes(hoveredBuilding.type, 'input')}</div>
          `;
          ioTooltip.style.display = 'block';
          ioTooltip.style.left = (e.clientX + 15) + 'px';
          ioTooltip.style.top = (e.clientY + 15) + 'px';
          
          // Show regular node tooltip but with reduced opacity
          nodeTooltip.innerHTML = `
            <div style="font-weight: bold; color: #A78BFA; margin-bottom: 5px;">${nodeInfo.name}</div>
            <div style="margin-bottom: 8px;">${nodeInfo.description}</div>
            <div style="font-size: 12px; color: #9CA3AF;">Tools: ${nodeInfo.tools.join(', ')}</div>
          `;
          nodeTooltip.style.display = 'block';
          nodeTooltip.style.opacity = '0.5';
          nodeTooltip.style.left = (e.clientX + 15) + 'px';
          nodeTooltip.style.top = (e.clientY + 60) + 'px';
        } 
        else if (isOverOutput) {
          // Show output tooltip
          ioTooltip.innerHTML = `
            <div style="font-weight: bold; color: #34D399; margin-bottom: 5px;">Output Connection</div>
            <div style="margin-bottom: 8px;">Connect this output to other nodes' inputs to send processed data.</div>
            <div style="font-size: 12px; color: #9CA3AF;">Provides: ${getOutputType(hoveredBuilding.type)}</div>
          `;
          ioTooltip.style.display = 'block';
          ioTooltip.style.left = (e.clientX + 15) + 'px';
          ioTooltip.style.top = (e.clientY + 15) + 'px';
          
          // Show regular node tooltip but with reduced opacity
          nodeTooltip.innerHTML = `
            <div style="font-weight: bold; color: #A78BFA; margin-bottom: 5px;">${nodeInfo.name}</div>
            <div style="margin-bottom: 8px;">${nodeInfo.description}</div>
            <div style="font-size: 12px; color: #9CA3AF;">Tools: ${nodeInfo.tools.join(', ')}</div>
          `;
          nodeTooltip.style.display = 'block';
          nodeTooltip.style.opacity = '0.5';
          nodeTooltip.style.left = (e.clientX + 15) + 'px';
          nodeTooltip.style.top = (e.clientY + 60) + 'px';
        } 
        else {
          // Show regular node tooltip
          nodeTooltip.innerHTML = `
            <div style="font-weight: bold; color: #A78BFA; margin-bottom: 5px;">${nodeInfo.name}</div>
            <div style="margin-bottom: 8px;">${nodeInfo.description}</div>
            <div style="font-size: 12px; color: #9CA3AF;">Tools: ${nodeInfo.tools.join(', ')}</div>
          `;
          nodeTooltip.style.display = 'block';
          nodeTooltip.style.opacity = '1';
          nodeTooltip.style.left = (e.clientX + 15) + 'px';
          nodeTooltip.style.top = (e.clientY + 15) + 'px';
          
          // Hide IO tooltip
          ioTooltip.style.display = 'none';
        }
      } else {
        // Hide both tooltips if not over a building
        nodeTooltip.style.display = 'none';
        ioTooltip.style.display = 'none';
      }
    });
    
    canvas.addEventListener('mouseup', function(e) {
      if (e.button === 1) { // Middle mouse button
        isDragging = false;
        canvas.style.cursor = 'default';
      }
    });
    
    canvas.addEventListener('mouseleave', function() {
      isDragging = false;
      canvas.style.cursor = 'default';
      // Hide tooltip when mouse leaves canvas
      nodeTooltip.style.display = 'none';
    });
    
    // Double-click to move to a node or location, or reset camera
    canvas.addEventListener('dblclick', function(e) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      const worldPos = game.camera.screenToWorld(mouseX, mouseY);
      
      // Check if clicked on a building
      let clickedOnBuilding = false;
      for (const b of game.buildings) {
        if (worldPos.x >= b.x && worldPos.x <= b.x + b.width &&
            worldPos.y >= b.y && worldPos.y <= b.y + b.height) {
          clickedOnBuilding = true;
          // Move player to building center and connect
          game.player.targetX = b.x + b.width/2;
          game.player.targetY = b.y + b.height/2;
          game.isMovingPlayer = true;
          // Player moving to building
          break;
        }
      }
      
      if (!clickedOnBuilding) {
        // If holding Shift key while double-clicking, toggle camera follow mode
        if (e.shiftKey) {
          game.camera.followPlayer = !game.camera.followPlayer;
          
          // Show a message about camera mode
          const message = document.createElement('div');
          message.className = 'camera-message';
          message.textContent = game.camera.followPlayer ? 
            'Camera locked to player.' : 
            'Camera unlocked. Use middle mouse to pan, double-click to move.';
          message.style.position = 'absolute';
          message.style.top = '120px';
          message.style.left = '50%';
          message.style.transform = 'translateX(-50%)';
          message.style.backgroundColor = 'rgba(31, 41, 55, 0.8)';
          message.style.color = '#F9FAFB';
          message.style.padding = '8px 12px';
          message.style.borderRadius = '4px';
          message.style.zIndex = '1000';
          message.style.pointerEvents = 'none';
          document.body.appendChild(message);
          
          // Remove the message after 2 seconds
          setTimeout(() => {
            document.body.removeChild(message);
          }, 2000);
        } else {
          // Move player to clicked location
          game.player.targetX = worldPos.x;
          game.player.targetY = worldPos.y;
          game.isMovingPlayer = true;
        }
      }
    });

    canvas.addEventListener('click', (e) => {
        if (game.isMovingPlayer) return;

        const rect = canvas.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;
        
        // Convert screen coordinates to world coordinates
        const worldPos = game.camera.screenToWorld(clickX, clickY);

        let clickedBuilding = null;
        for (const b of game.buildings) {
            // Click detection using world coordinates
            if (worldPos.x >= b.x && worldPos.x <= b.x + b.width &&
                worldPos.y >= b.y && worldPos.y <= b.y + b.height) {
                clickedBuilding = b;
                break;
            }
        }

        if (clickedBuilding) {
            showBuildingInfo(clickedBuilding);
        } else {
            hideBuildingInfo();
        }
    });

     canvas.addEventListener('dblclick', (e) => {
        if (terminalActive || game.isMovingPlayer) return;

        const rect = canvas.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;

        let dblClickedBuilding = null;
        for (const b of game.buildings) {
             // Double-Click detection based on the old drawing logic (top-left origin)
            if (clickX >= b.x && clickX <= b.x + b.width &&
                clickY >= b.y && clickY <= b.y + b.height) {
                dblClickedBuilding = b;
                break;
            }
        }

        if (dblClickedBuilding) {
            // Move player towards the *center* of the clicked building for better visuals
            movePlayerTo(dblClickedBuilding.x + dblClickedBuilding.width / 2, dblClickedBuilding.y + dblClickedBuilding.height / 2);
        }
     });


    // --- Drawing Functions (Updates) ---
    function drawPlayer(x, y, size, rotation) {
      ctx.save();
      ctx.translate(game.player.x, game.player.y);
      ctx.rotate(game.player.rotation);
      
      // Main body (triangle)
      ctx.beginPath();
      ctx.moveTo(game.player.size * 0.8, 0);
      ctx.lineTo(-game.player.size * 0.6, -game.player.size * 0.5);
      ctx.lineTo(-game.player.size * 0.4, 0);
      ctx.lineTo(-game.player.size * 0.6, game.player.size * 0.5);
      ctx.closePath();
      
      ctx.fillStyle = colors.player;
      ctx.shadowColor = colors.player;
      ctx.shadowBlur = 15;
      ctx.fill();
      
      // Outline
      ctx.strokeStyle = '#E5E7EB';
      ctx.lineWidth = 1.5;
      ctx.stroke();
      
      // Cockpit line
      ctx.beginPath();
      ctx.moveTo(game.player.size * 0.3, 0);
      ctx.lineTo(game.player.size * 0.1, 0);
      ctx.strokeStyle = 'rgba(229, 231, 235, 0.5)';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      ctx.restore();
    }

    function drawPet(pet) {
        // ... Keep the current drawPet function ...
          ctx.save();
          ctx.translate(pet.x, pet.y);
          ctx.rotate(pet.rotation);
          ctx.beginPath();
          if (pet.color === colors.pet1) { // Chevron
              ctx.moveTo(pet.size * 0.8, 0);
              ctx.lineTo(-pet.size * 0.4, -pet.size * 0.5);
              ctx.lineTo(-pet.size * 0.4, pet.size * 0.5);
          } else { // Diamond
               ctx.moveTo(pet.size * 0.8, 0); ctx.lineTo(0, -pet.size * 0.5);
               ctx.lineTo(-pet.size * 0.8, 0); ctx.lineTo(0, pet.size * 0.5);
          }
          ctx.closePath();
          ctx.fillStyle = pet.color;
          ctx.shadowColor = pet.color; ctx.shadowBlur = 10;
          ctx.fill();
          ctx.strokeStyle = '#E5E7EB'; ctx.lineWidth = 1;
          ctx.stroke();
          ctx.restore();
    }

    // --- Enhanced drawBuilding FUNCTION with NOTCH ---
function drawBuilding(b) {
  ctx.save();
  ctx.translate(b.x, b.y);
  
  // Task highlight - add a pulsing outline if this building is part of the current task
  let isTaskNode = false;
  if (game.mode === 'challenge' && game.currentTask) {
    if ((game.currentTask.srcBuilding === b) || 
        (game.currentTask.tgtBuilding === b) || 
        (game.currentTask.midBuilding === b)) {
      isTaskNode = true;
      const pulseIntensity = 0.5 + 0.5 * Math.sin(Date.now() / 300);
      
      // Draw task highlight glow
      ctx.shadowColor = game.currentTask.srcBuilding === b ? '#60A5FA' : 
                       game.currentTask.tgtBuilding === b ? '#34D399' : '#F59E0B';
      ctx.shadowBlur = 15 + 10 * pulseIntensity;
      
      // Draw task indicator text above building
      ctx.font = 'bold 14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillStyle = game.currentTask.srcBuilding === b ? '#60A5FA' : 
                     game.currentTask.tgtBuilding === b ? '#34D399' : '#F59E0B';
      ctx.fillText(
        game.currentTask.srcBuilding === b ? 'SOURCE' : 
        game.currentTask.tgtBuilding === b ? 'TARGET' : 'MIDDLE',
        b.width/2, -15
      );
    }
  }
  
  // Glow for active/processing
  if (!isTaskNode && (b.active || b.processing)) {
    ctx.shadowColor = colors.accent;
    ctx.shadowBlur = 24 + 8 * Math.sin(Date.now()/200);
  }
  
  ctx.fillStyle = b.color || '#888';
  ctx.strokeStyle = 'rgba(255,255,255,0.7)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(b.width, 0);
  ctx.lineTo(b.width, b.height * 0.7); // notch start
  ctx.lineTo(b.width * 0.7, b.height); // notch corner
  ctx.lineTo(0, b.height);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  ctx.shadowBlur = 0;

  // Lock indicator handled via status dot color

  // Internal lines
  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.lineWidth = 1;
  for (let i = 1; i < 3; i++) {
    ctx.beginPath();
    const lineX = b.width * (i / 3);
    ctx.moveTo(lineX, 0);
    // Stop at notch if below notch
    if (lineX > b.width * 0.7) {
      ctx.lineTo(lineX, b.height * 0.7);
    } else {
      ctx.lineTo(lineX, b.height);
    }
    ctx.stroke();
  }
  
  // Draw input/output indicators
  // Input indicator (left side)
  ctx.fillStyle = 'rgba(255,255,255,0.7)';
  ctx.beginPath();
  ctx.moveTo(0, b.height/2 - 10);
  ctx.lineTo(10, b.height/2);
  ctx.lineTo(0, b.height/2 + 10);
  ctx.closePath();
  ctx.fill();
  
  // Output indicator (right side)
  ctx.beginPath();
  if (b.width * 0.7 > b.width - 10) {
    // If notch is in the way, place indicator higher
    ctx.moveTo(b.width, b.height * 0.3 - 10);
    ctx.lineTo(b.width - 10, b.height * 0.3);
    ctx.lineTo(b.width, b.height * 0.3 + 10);
  } else {
    ctx.moveTo(b.width, b.height/2 - 10);
    ctx.lineTo(b.width - 10, b.height/2);
    ctx.lineTo(b.width, b.height/2 + 10);
  }
  ctx.closePath();
  ctx.fill();
  
  // Node status dot
  ctx.beginPath();
  ctx.arc(b.width/2, b.height + 10, 7, 0, 2 * Math.PI);
  // Color logic: locked (red) > active (accent) > idle (gray)
  ctx.fillStyle = b.locked ? '#EF4444' : b.active ? colors.accent : '#E5E7EB';
  ctx.globalAlpha = 0.9;
  ctx.fill();
  ctx.globalAlpha = 1.0;
  ctx.restore();
}

    // *** END OF REPLACED FUNCTION ***


    // --- Update Loop ---
    function update() {
      // Handle auto-movement to target position when double-clicking
      if (game.isMovingPlayer) {
        const dx = game.player.targetX - game.player.x;
        const dy = game.player.targetY - game.player.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // If we're close enough to the target, stop moving
        if (distance < 5) {
          game.isMovingPlayer = false;
          // If we reached a building, try to connect to it
          for (const b of game.buildings) {
            const bCenterX = b.x + b.width/2;
            const bCenterY = b.y + b.height/2;
            const dxB = game.player.x - bCenterX;
            const dyB = game.player.y - bCenterY;
            const distToBuilding = Math.sqrt(dxB * dxB + dyB * dyB);
            
            if (distToBuilding < 30) { // Close enough to connect
              if (!b.locked) {
                showTerminal(b);
              } else {
                // Visual feedback for locked node
                game.particles.emit(bCenterX, bCenterY, colors.accent, 3, 8, [2,5], 0.8);
              }
              break;
            }
          }
        } else {
          // Move towards the target
          const moveSpeed = Math.min(distance, game.player.speed);
          const angle = Math.atan2(dy, dx);
          game.player.x += Math.cos(angle) * moveSpeed;
          game.player.y += Math.sin(angle) * moveSpeed;
          game.player.rotation = angle;
          
          // Update pets when moving automatically too
          game.pets.forEach(pet => {
            const petAngle = game.player.rotation;
            const rotatedOffsetX = pet.targetOffset.x * Math.cos(petAngle) - pet.targetOffset.y * Math.sin(petAngle);
            const rotatedOffsetY = pet.targetOffset.x * Math.sin(petAngle) + pet.targetOffset.y * Math.cos(petAngle);
            const targetX = game.player.x + rotatedOffsetX;
            const targetY = game.player.y + rotatedOffsetY;
            pet.x += (targetX - pet.x) * pet.lerpFactor;
            pet.y += (targetY - pet.y) * pet.lerpFactor;
            pet.rotation = petAngle;
          });
        }
      }
      
      // Terminal Interaction Check (E key) - moved outside the movement block so it works all the time
      if (game.keys['e'] && !terminalCooldown && !terminalActive) {
          terminalCooldown = true;
          setTimeout(() => terminalCooldown = false, 300);

          let closestBuilding = null;
          let minDistSq = Infinity; // Use squared distance for comparison efficiency

          for (const b of game.buildings) {
              // Check distance from player to building CENTER for interaction range
              const dxB = game.player.x - (b.x + b.width / 2);
              const dyB = game.player.y - (b.y + b.height / 2);
              const distSq = dxB * dxB + dyB * dyB; // Squared distance
              // Interaction radius based on building center + margin
              const interactionRadius = Math.max(b.width, b.height) / 2 + 60;

              if (distSq < interactionRadius * interactionRadius && distSq < minDistSq) {
                   minDistSq = distSq;
                   closestBuilding = b;
              }
          }

          if (closestBuilding) {
              if (!closestBuilding.locked) {
                   showTerminal(closestBuilding);
              } else {
                   // Show locked terminal view instead
                   showLockedTerminal(closestBuilding);
                   // Visual feedback
                   game.particles.emit(closestBuilding.x+closestBuilding.width/2, closestBuilding.y+closestBuilding.height/2, '#EF4444', 3, 8, [2,5], 0.8);
              }
          }
      }
      
      // Skip regular game logic update if terminal is active OR player is auto-moving
      if (!terminalActive && !game.isMovingPlayer) {
          game.particles.update(); // *** UPDATE PARTICLES ***

          // Pet movement
          game.pets.forEach(pet => {
            const angle = game.player.rotation;
            const rotatedOffsetX = pet.targetOffset.x * Math.cos(angle) - pet.targetOffset.y * Math.sin(angle);
            const rotatedOffsetY = pet.targetOffset.x * Math.sin(angle) + pet.targetOffset.y * Math.cos(angle);
            const targetX = game.player.x + rotatedOffsetX;
            const targetY = game.player.y + rotatedOffsetY;
            pet.x += (targetX - pet.x) * pet.lerpFactor;
            pet.y += (targetY - pet.y) * pet.lerpFactor;
            const dxToTarget = targetX - pet.x; const dyToTarget = targetY - pet.y;
            pet.rotation = Math.atan2(dyToTarget, dxToTarget);
            if (Math.random() < 0.03) {
              game.particles.emit(pet.x, pet.y, pet.color, 1, 2, [1, 3]);
            }
          });

          // Player movement input
          let moveX = 0; let moveY = 0;
          let rotating = false;
          if (game.keys['arrowup'] || game.keys['w']) { moveY = 1; }
          if (game.keys['arrowdown'] || game.keys['s']) { moveY = -0.6; } // Slower reverse
          if (game.keys['arrowleft'] || game.keys['a']) { game.player.rotation -= 0.08; rotating = true; }
          if (game.keys['arrowright'] || game.keys['d']) { game.player.rotation += 0.08; rotating = true; }

          // Apply movement based on rotation
          const moveMagnitude = Math.abs(moveY); // Use magnitude for forward/backward speed
          if (moveMagnitude > 0) {
              const moveDir = moveY > 0 ? 1 : -1; // Forward or backward
              game.player.x += Math.cos(game.player.rotation) * game.player.speed * moveDir * (moveDir > 0 ? 1 : 0.6); // Apply reverse penalty
              game.player.y += Math.sin(game.player.rotation) * game.player.speed * moveDir * (moveDir > 0 ? 1 : 0.6);
              // Thrust particles only when moving forward
               if (moveDir > 0 && Math.random() < 0.5) {
                    const backOffsetX = -game.player.size * 0.7;
                    const emissionX = game.player.x + backOffsetX * Math.cos(game.player.rotation);
                    const emissionY = game.player.y + backOffsetX * Math.sin(game.player.rotation);
                    game.particles.emit(emissionX, emissionY, colors.accent, 2, 2, [2, 4]);
               }
          }


          // Focus logic
          let inSafeZone = false;
          let currentRegen = 0;
          for (const building of game.buildings) {
            // Calculate distance from player to building CENTER for safe zone check
            const dxB = game.player.x - (building.x + building.width / 2);
            const dyB = game.player.y - (building.y + building.height / 2);
            const distance = Math.hypot(dxB, dyB);
            if (distance < building.radius) { // Safe zone radius is still based on center
              inSafeZone = true;
              currentRegen = building.regen; // Get regen rate from current building
              // Optional: Safe zone particles
              if (Math.random() < 0.02) {
                  game.particles.emit(game.player.x + (Math.random()-0.5)*20, game.player.y + (Math.random()-0.5)*20, building.color+'55', 0.5, 1, [1,2], 0.5);
              }
              break; // Only one zone affects at a time
            }
          }

          if (inSafeZone) {
            game.player.focus = Math.min(game.player.maxFocus, game.player.focus + currentRegen);
          } else {
            game.player.focus = Math.max(0, game.player.focus - 0.08); // Drain outside
          }

          // UI Update (Focus Bar & Stats)
          const ratio = game.player.focus / game.player.maxFocus;
          focusBar.style.width = (ratio * 100) + '%';
          const hue = ratio * 120; // 0 (red) to 120 (green)
          focusBar.style.backgroundColor = `hsl(${hue}, 80%, 45%)`;
          stats.textContent = `FCS: ${Math.floor(game.player.focus)}% | POS: ${Math.floor(game.player.x)}, ${Math.floor(game.player.y)}`;
      } // End of if(!terminalActive && !game.isMovingPlayer) block
    }

    // --- Draw Loop ---
function draw() {
  // Clear canvas
  ctx.fillStyle = colors.background;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Update camera to follow player
  game.camera.update();
  
  // Save the context state before applying camera transformations
  ctx.save();
  
  // Apply camera transformations
  ctx.translate(canvas.width / 2, canvas.height / 2);
  ctx.scale(game.camera.zoom, game.camera.zoom);
  ctx.translate(-game.camera.x, -game.camera.y);
  
  // Draw Grid - now using world coordinates
  ctx.strokeStyle = 'rgba(55, 65, 81, 0.3)'; ctx.lineWidth = 0.5;
  const gridSize = 100;
  
  // Calculate grid boundaries based on camera position and zoom
  const viewWidth = canvas.width / game.camera.zoom;
  const viewHeight = canvas.height / game.camera.zoom;
  const startX = Math.floor((game.camera.x - viewWidth/2) / gridSize) * gridSize;
  const endX = Math.ceil((game.camera.x + viewWidth/2) / gridSize) * gridSize;
  const startY = Math.floor((game.camera.y - viewHeight/2) / gridSize) * gridSize;
  const endY = Math.ceil((game.camera.y + viewHeight/2) / gridSize) * gridSize;
  
  // Draw vertical grid lines
  for (let x = startX; x <= endX; x += gridSize) { 
    ctx.beginPath(); 
    ctx.moveTo(x, startY); 
    ctx.lineTo(x, endY); 
    ctx.stroke(); 
  }
  
  // Draw horizontal grid lines
  for (let y = startY; y <= endY; y += gridSize) { 
    ctx.beginPath(); 
    ctx.moveTo(startX, y); 
    ctx.lineTo(endX, y); 
    ctx.stroke(); 
  }

  // Draw Building Safe Zones (Still based on building center)
  for (const building of game.buildings) {
    const centerX = building.x + building.width / 2; const centerY = building.y + building.height / 2;
    const g = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, building.radius);
    const zoneColor = (building.color || '#6366F1') + '1A'; // Use building color or fallback
    g.addColorStop(0, zoneColor); g.addColorStop(0.7, zoneColor); g.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(centerX, centerY, building.radius, 0, Math.PI * 2); ctx.fill();
    // Zone outline
    ctx.strokeStyle = (building.color || '#6366F1') + '33';
    ctx.lineWidth = 1; ctx.setLineDash([4, 8]);
    ctx.beginPath(); ctx.arc(centerX, centerY, building.radius, 0, Math.PI * 2); ctx.stroke();
    ctx.setLineDash([]);
  }

  // Draw Network Connections (between all buildings)
  ctx.save();
  ctx.strokeStyle = colors.network + 'B0'; ctx.lineWidth = 2; ctx.setLineDash([8, 12]);
  for (let i = 0; i < game.buildings.length; i++) {
    for (let j = i + 1; j < game.buildings.length; j++) {
      const b1 = game.buildings[i]; const b2 = game.buildings[j];
      ctx.beginPath();
      ctx.moveTo(b1.x + b1.width / 2, b1.y + b1.height / 2);
      ctx.lineTo(b2.x + b2.width / 2, b2.y + b2.height / 2);
      ctx.stroke();
      // Animate packet if edge is active
      if ((b1.active || b2.active || networkScanActive)) {
        const animTime = ((Date.now()/400) % 1);
        const packetX = (b1.x + b1.width/2) + (b2.x + b2.width/2 - (b1.x + b1.width/2)) * animTime;
        const packetY = (b1.y + b1.height/2) + (b2.y + b2.height/2 - (b1.y + b1.height/2)) * animTime;
        ctx.beginPath();
        ctx.arc(packetX, packetY, 7, 0, 2 * Math.PI);
        ctx.fillStyle = b1.active || b2.active ? colors.accent : colors.network;
        ctx.globalAlpha = 0.7;
        ctx.fill();
        ctx.globalAlpha = 1.0;
      }
    }
  }
  ctx.restore();
  ctx.setLineDash([]);
  
  // Draw all buildings
  for (const b of game.buildings) {
    drawBuilding(b);
  }
  
  // Draw connections between active nodes
  if (game.connections.length > 0) {
    // Draw stored connections
    for (const connection of game.connections) {
      const from = connection.from;
      const to = connection.to;
      
      if (from.active && to.active) {
        // Pulse effect based on time
        const pulseSpeed = 2000; // ms for one complete cycle
        const timeSinceEstablished = Date.now() - connection.established;
        const pulsePhase = (timeSinceEstablished % pulseSpeed) / pulseSpeed;
        
        // Draw the main connection line
        ctx.strokeStyle = colors.network;
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]); // Dashed lines
        ctx.beginPath();
        ctx.moveTo(from.x + from.width/2, from.y + from.height/2);
        ctx.lineTo(to.x + to.width/2, to.y + to.height/2);
        ctx.stroke();
        
        // Draw pulse dot moving along the line
        const fromX = from.x + from.width/2;
        const fromY = from.y + from.height/2;
        const toX = to.x + to.width/2;
        const toY = to.y + to.height/2;
        
        // Calculate position along the line (0 to 1)
        const pulsePosition = (pulsePhase + 1) / 2; // Convert -1 to 1 range to 0 to 1
        const pulseX = fromX + (toX - fromX) * pulsePosition;
        const pulseY = fromY + (toY - fromY) * pulsePosition;
        
        // Draw pulse
        ctx.fillStyle = colors.accent;
        ctx.beginPath();
        ctx.arc(pulseX, pulseY, 4, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    ctx.setLineDash([]); // Reset to solid lines
  }

  // Draw Pets
  for (const pet of game.pets) {
    drawPet(pet);
  }

  // Draw Player
  drawPlayer();

  // Draw Particles
  game.particles.draw(ctx);
  
  // Draw task path indicator if in challenge mode (inside camera transform)
  if (game.mode === 'challenge' && game.currentTask && !game.currentTask.completed) {
    drawTaskPathIndicator();
  }
  
  // Restore the context to remove camera transformations
  ctx.restore();
  
  // Draw mini-map in the corner (outside the camera transform)
  drawMiniMap();
  
  // Draw first step instruction (outside camera transform)
  if (game.mode === 'challenge' && game.currentTask && !game.currentTask.completed) {
    ctx.save();
    ctx.font = 'bold 16px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#FFFFFF';
    
    // Create instruction text with drop shadow for better visibility
    const instructionText = `First: Go to the SOURCE node (${BUILDING_DEFAULTS[game.currentTask.srcType].name})`;
    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
    ctx.shadowBlur = 5;
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;
    
    // Position at top center of screen
    ctx.fillText(instructionText, canvas.width / 2, 30);
    ctx.restore();
  }
  
  // Draw legend in top-right corner
  ctx.save();
  ctx.font = '14px monospace';
  ctx.textBaseline = 'middle';
  ctx.globalAlpha = 0.8;
  ctx.fillStyle = '#18181b';
  const legendX = canvas.width - 180;
  ctx.fillRect(legendX, 30, 162, 92);
  ctx.globalAlpha = 1;
  ctx.fillStyle = colors.player; ctx.fillText('▲ Player', legendX + 12, 50);
  ctx.fillStyle = colors.accent; ctx.fillText('● Active Node', legendX + 12, 68);
  ctx.fillStyle = colors.network; ctx.fillText('━ Pipeline', legendX + 12, 86);
  ctx.fillStyle = '#E5E7EB'; ctx.fillText('○ Idle Node', legendX + 12, 104);
  ctx.fillStyle = '#EF4444'; ctx.fillText('● Locked Node', legendX + 12, 122);
  ctx.restore();
  
  // Draw controls help in bottom left
  ctx.save();
  ctx.font = '14px monospace';
  ctx.textBaseline = 'middle';
  ctx.globalAlpha = 0.8;
  ctx.fillStyle = '#18181b';
  ctx.fillRect(18, canvas.height - 100, 220, 80);
  ctx.globalAlpha = 1;
  ctx.fillStyle = '#F9FAFB';
  ctx.fillText('Controls:', 30, canvas.height - 80);
  ctx.fillStyle = '#D1D5DB';
  ctx.fillText('WASD/Arrows: Move', 30, canvas.height - 60);
  ctx.fillText('Double-click: Move to node', 30, canvas.height - 40);
  ctx.fillText('Mouse wheel: Zoom in/out', 30, canvas.height - 20);
  ctx.restore();
}

// Draw a mini-map in the corner
function drawMiniMap() {
  const mapSize = 150;
  const mapX = canvas.width - mapSize - 20;
  const mapY = canvas.height - mapSize - 20;
  const mapScale = 0.1;
  
  // Draw mini-map background
  ctx.fillStyle = 'rgba(31, 41, 55, 0.8)';
  ctx.fillRect(mapX, mapY, mapSize, mapSize);
  ctx.strokeStyle = '#4B5563';
  ctx.lineWidth = 2;
  ctx.strokeRect(mapX, mapY, mapSize, mapSize);
  
  // Draw buildings on mini-map
  for (const b of game.buildings) {
    // Highlight task buildings on minimap
    if (game.mode === 'challenge' && game.currentTask && 
        (game.currentTask.srcBuilding === b || 
         game.currentTask.tgtBuilding === b || 
         game.currentTask.midBuilding === b)) {
      ctx.fillStyle = game.currentTask.srcBuilding === b ? '#60A5FA' : 
                     game.currentTask.tgtBuilding === b ? '#34D399' : '#F59E0B';
      const miniX = mapX + (b.x * mapScale) + mapSize/2 - (game.camera.x * mapScale);
      const miniY = mapY + (b.y * mapScale) + mapSize/2 - (game.camera.y * mapScale);
      ctx.fillRect(miniX - 3, miniY - 3, 6, 6);
    } else {
      ctx.fillStyle = b.color || '#888';
      const miniX = mapX + (b.x * mapScale) + mapSize/2 - (game.camera.x * mapScale);
      const miniY = mapY + (b.y * mapScale) + mapSize/2 - (game.camera.y * mapScale);
      ctx.fillRect(miniX - 2, miniY - 2, 4, 4);
    }
  }
  
  // Draw player on mini-map
  ctx.fillStyle = colors.player;
  const playerMiniX = mapX + (game.player.x * mapScale) + mapSize/2 - (game.camera.x * mapScale);
  const playerMiniY = mapY + (game.player.y * mapScale) + mapSize/2 - (game.camera.y * mapScale);
  ctx.beginPath();
  ctx.arc(playerMiniX, playerMiniY, 3, 0, Math.PI * 2);
  ctx.fill();
  
  // Draw viewport rectangle
  ctx.strokeStyle = '#10B981';
  ctx.lineWidth = 1;
  const viewWidth = (canvas.width / game.camera.zoom) * mapScale;
  const viewHeight = (canvas.height / game.camera.zoom) * mapScale;
  ctx.strokeRect(
    mapX + mapSize/2 - viewWidth/2,
    mapY + mapSize/2 - viewHeight/2,
    viewWidth,
    viewHeight
  );
}

// Draw a visual path indicator for the current task
function drawTaskPathIndicator() {
  if (!game.currentTask || !game.currentTask.srcBuilding || !game.currentTask.tgtBuilding) {
    return;
  }
  
  const src = game.currentTask.srcBuilding;
  const tgt = game.currentTask.tgtBuilding;
  const mid = game.currentTask.midBuilding;
  
  // Save context for path drawing
  ctx.save();
  
  // Draw a path from player to source node if player is not close to any task node
  const distToSrc = Math.hypot(game.player.x - src.x - src.width/2, game.player.y - src.y - src.height/2);
  const distToMid = mid ? Math.hypot(game.player.x - mid.x - mid.width/2, game.player.y - mid.y - mid.height/2) : Infinity;
  const distToTgt = Math.hypot(game.player.x - tgt.x - tgt.width/2, game.player.y - tgt.y - tgt.height/2);
  
  // If player is far from all task nodes, draw a path to the source
  if (distToSrc > 100 && distToMid > 100 && distToTgt > 100) {
    ctx.setLineDash([3, 8]);
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
    
    // Calculate source center in world coordinates
    const srcCenterX = src.x + src.width/2;
    const srcCenterY = src.y + src.height/2;
    
    // Draw path from player to source
    ctx.beginPath();
    ctx.moveTo(game.player.x, game.player.y);
    ctx.lineTo(srcCenterX, srcCenterY);
    ctx.stroke();
    
    // Draw animated arrows along the path
    const arrowOffset = (Date.now() / 800) % 1;
    drawAnimatedArrows(game.player.x, game.player.y, srcCenterX, srcCenterY, arrowOffset, 'rgba(255, 255, 255, 0.8)');
  }
  
  // Draw the task path
  ctx.setLineDash([5, 10]);
  ctx.lineWidth = 3;
  
  // Draw path from source to target (or through middle if applicable)
  if (mid) {
    // Source to middle
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(96, 165, 250, 0.5)'; // Blue
    ctx.moveTo(src.x + src.width/2, src.y + src.height/2);
    ctx.lineTo(mid.x + mid.width/2, mid.y + mid.height/2);
    ctx.stroke();
    
    // Middle to target
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(52, 211, 153, 0.5)'; // Green
    ctx.moveTo(mid.x + mid.width/2, mid.y + mid.height/2);
    ctx.lineTo(tgt.x + tgt.width/2, tgt.y + tgt.height/2);
    ctx.stroke();
  } else {
    // Direct source to target
    ctx.beginPath();
    // Create gradient for the line
    const gradient = ctx.createLinearGradient(
      src.x + src.width/2, src.y + src.height/2,
      tgt.x + tgt.width/2, tgt.y + tgt.height/2
    );
    gradient.addColorStop(0, 'rgba(96, 165, 250, 0.5)'); // Blue at start
    gradient.addColorStop(1, 'rgba(52, 211, 153, 0.5)'); // Green at end
    
    ctx.strokeStyle = gradient;
    ctx.moveTo(src.x + src.width/2, src.y + src.height/2);
    ctx.lineTo(tgt.x + tgt.width/2, tgt.y + tgt.height/2);
    ctx.stroke();
  }
  
  // Draw animated arrows along the path
  const arrowOffset = (Date.now() / 1000) % 1; // Value between 0 and 1 that cycles every second
  
  if (mid) {
    // Arrows from source to middle
    drawAnimatedArrows(src.x + src.width/2, src.y + src.height/2, 
                      mid.x + mid.width/2, mid.y + mid.height/2, 
                      arrowOffset, 'rgba(96, 165, 250, 0.8)');
    
    // Arrows from middle to target
    drawAnimatedArrows(mid.x + mid.width/2, mid.y + mid.height/2, 
                      tgt.x + tgt.width/2, tgt.y + tgt.height/2, 
                      arrowOffset, 'rgba(52, 211, 153, 0.8)');
  } else {
    // Arrows directly from source to target
    drawAnimatedArrows(src.x + src.width/2, src.y + src.height/2, 
                      tgt.x + tgt.width/2, tgt.y + tgt.height/2, 
                      arrowOffset, 'rgba(96, 165, 250, 0.8)');
  }
  
  ctx.setLineDash([]);
  ctx.restore();
}

// Helper function to draw animated arrows along a path
function drawAnimatedArrows(x1, y1, x2, y2, offset, color) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  const distance = Math.sqrt(dx * dx + dy * dy);
  const numArrows = Math.max(1, Math.floor(distance / 100));
  
  // Draw arrows along the path
  for (let i = 0; i < numArrows; i++) {
    const t = (i / numArrows + offset) % 1;
    const arrowX = x1 + dx * t;
    const arrowY = y1 + dy * t;
    const angle = Math.atan2(dy, dx);
    
    ctx.save();
    ctx.translate(arrowX, arrowY);
    ctx.rotate(angle);
    
    // Draw arrow
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(-10, -5);
    ctx.lineTo(-7, 0);
    ctx.lineTo(-10, 5);
    ctx.closePath();
    ctx.fill();
    
    ctx.restore();
  }
}
    // --- Game Loop ---
function gameLoop() {
  update();
  draw();
  updateGameUI();
  requestAnimationFrame(gameLoop);
}

// Update game UI elements
function updateGameUI() {
  // Only update challenge mode UI if in challenge mode
  if (game.mode === 'challenge') {
    // Update score display
    document.getElementById('score').textContent = `Score: ${game.score}`;
    document.getElementById('tasks-completed').textContent = `Tasks: ${game.completedTasks}`;
    
    // Update task timer if we have an active task
    if (game.currentTask && !game.currentTask.completed) {
      const elapsed = Date.now() - game.currentTask.startTime;
      const remaining = Math.max(0, game.currentTask.timeLimit - elapsed);
      const minutes = Math.floor(remaining / 60000);
      const seconds = Math.floor((remaining % 60000) / 1000);
      document.getElementById('task-timer').textContent = `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
      
      // Time's up?
      if (remaining <= 0 && !game.currentTask.completed) {
        // Task failed
        game.currentTask.completed = true;
        if (terminalActive) {
          typeLine(`>> Time's up! Task failed.`, { className: 'error' });
          setTimeout(() => {
            // Generate new task
            game.currentTask = generateTask();
            typeLine(`>> New ${game.currentTask.message}`, { className: 'system' });
          }, 2000);
        }
      }
    }
  }
  
  // Check for sandbox mode progression
  if (game.mode === 'sandbox') {
    checkSandboxProgress();
  }
}

// Function to check and progress through sandbox tutorial steps
function checkSandboxProgress() {
  if (game.currentSandboxStep >= game.sandboxSteps.length) return;
  
  const currentStep = game.sandboxSteps[game.currentSandboxStep];
  
  // Check if the current step is complete based on its type
  let stepComplete = false;
  
  switch (currentStep.type) {
    case 'welcome':
      // Auto-advance after a few seconds
      if (!currentStep.shown) {
        currentStep.shown = true;
        setTimeout(() => {
          game.currentSandboxStep++;
        }, 5000);
      }
      break;
      
    case 'movement':
      // Complete when player moves
      if (game.player.x !== 400 || game.player.y !== 300) {
        stepComplete = true;
      }
      break;
      
    case 'connect':
      // Complete when terminal is opened
      if (terminalActive) {
        stepComplete = true;
      }
      break;
      
    case 'help':
      // Check if help command was used
      if (terminalActive && commandHistory.some(cmd => cmd.toLowerCase() === 'help')) {
        stepComplete = true;
      }
      break;
      
    case 'tools':
      // Check if list tools command was used
      if (terminalActive && commandHistory.some(cmd => cmd.toLowerCase() === 'list tools')) {
        stepComplete = true;
      }
      break;
      
    case 'send':
      // Check if send command was attempted
      if (terminalActive && commandHistory.some(cmd => cmd.toLowerCase().startsWith('send'))) {
        stepComplete = true;
      }
      break;
      
    case 'connection':
      // Check if a connection was made
      if (game.connections.length > 0) {
        stepComplete = true;
      }
      break;
      
    case 'complete':
      // This is the final step, no auto-advancement
      break;
  }
  
  // Advance to next step if current step is complete
  if (stepComplete) {
    game.currentSandboxStep++;
    
    // Show the next step's guidance
    if (game.currentSandboxStep < game.sandboxSteps.length) {
      const nextStep = game.sandboxSteps[game.currentSandboxStep];
      if (terminalActive) {
        typeLine(`>> ${nextStep.message}`, { className: 'system' });
      }
    }
  }
}

    // --- Initial Setup ---
    resize(); // Initial resize to set canvas dimensions
    game.buildings = generateBuildings(7); // Generate buildings after resize
    
    // Mode switching functionality
    const sandboxBtn = document.getElementById('sandbox-mode');
    const challengeBtn = document.getElementById('challenge-mode');
    const gameStats = document.getElementById('game-stats');
    
    sandboxBtn.addEventListener('click', () => {
      if (game.mode !== 'sandbox') {
        // Switch to sandbox mode
        game.mode = 'sandbox';
        sandboxBtn.classList.add('active');
        challengeBtn.classList.remove('active');
        gameStats.style.display = 'none';
        
        // Reset sandbox progress
        game.currentSandboxStep = 0;
        
        // Show welcome message if terminal is active
        if (terminalActive) {
          typeLine(`>> ${game.sandboxSteps[0].message}`, { className: 'system' });
        }
      }
    });
    
    challengeBtn.addEventListener('click', () => {
      if (game.mode !== 'challenge') {
        // Switch to challenge mode
        game.mode = 'challenge';
        challengeBtn.classList.add('active');
        sandboxBtn.classList.remove('active');
        gameStats.style.display = 'block';
        
        // Always reset the task and timer when switching to challenge mode
        // This gives users a fresh 2 minutes for each attempt
        game.currentTask = generateTask();
        game.currentTask.startTime = Date.now(); // Reset the timer
        
        // Show challenge intro if terminal is active
        if (terminalActive) {
          typeLine(`>> Challenge Mode activated! You have 2 minutes for this attempt.`, { className: 'system' });
          typeLine(`>> ${game.currentTask.message}`, { className: 'system' });
          typeLine(`>> Tip: Switch back to Sandbox mode anytime to learn more about the nodes.`, { className: 'info' });
        }
      }
    });
    
    // Initialize based on starting mode
    if (game.mode === 'sandbox') {
      // Show first sandbox step when terminal is first opened
      // This is handled in the showTerminal override
    } else {
      // Initialize challenge mode
      game.currentTask = generateTask();
      gameStats.style.display = 'block';
      sandboxBtn.classList.remove('active');
      challengeBtn.classList.add('active');
    }

    // --- Terminal Resize Logic ---
    (function() {
      const term = document.getElementById('terminal');
      const handle = document.getElementById('terminal-resize-handle');
      let resizing = false;
      let startX, startY, startWidth, startHeight;
      handle.addEventListener('mousedown', function(e) {
        e.preventDefault();
        resizing = true;
        startX = e.clientX;
        startY = e.clientY;
        startWidth = term.offsetWidth;
        startHeight = term.offsetHeight;
        document.body.style.userSelect = 'none';
      });
      window.addEventListener('mousemove', function(e) {
        if (!resizing) return;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        let newWidth = Math.max(220, startWidth + dx);
        let newHeight = Math.max(120, startHeight + dy);
        newWidth = Math.min(window.innerWidth * 0.9, newWidth);
        newHeight = Math.min(window.innerHeight * 0.7, newHeight);
        term.style.width = newWidth + 'px';
        term.style.height = newHeight + 'px';
      });
      window.addEventListener('mouseup', function() {
        if (resizing) {
          resizing = false;
          document.body.style.userSelect = '';
        }
      });
    })();

    // --- Game Progression System ---
    function generateTask() {
        // Pick random source and target nodes of different types
        const types = Object.keys(BUILDING_DEFAULTS);
        let srcType, tgtType, midType;
        
        // Get available (unlocked) buildings of each type
        const availableBuildings = {};
        types.forEach(type => {
            availableBuildings[type] = game.buildings.filter(b => b.type === type && !b.locked);
        });
        
        // Filter to types that have at least one unlocked building
        const availableTypes = types.filter(type => availableBuildings[type].length > 0);
        
        // If we don't have at least 2 different available types, unlock some buildings
        if (availableTypes.length < 2) {
            // Unlock a data_source and a processor if none are available
            const toUnlock = ['data_source', 'processor'];
            toUnlock.forEach(type => {
                const lockedBuilding = game.buildings.find(b => b.type === type && b.locked);
                if (lockedBuilding) {
                    lockedBuilding.locked = false;
                    // Add visual feedback
                    game.particles.emit(lockedBuilding.x + lockedBuilding.width/2, 
                                      lockedBuilding.y + lockedBuilding.height/2, 
                                      '#10B981', 10, 20, [2,5], 1.5);
                }
            });
        }
        
        // Recalculate available buildings
        types.forEach(type => {
            availableBuildings[type] = game.buildings.filter(b => b.type === type && !b.locked);
        });
        
        // Update available types
        const updatedAvailableTypes = types.filter(type => availableBuildings[type].length > 0);
        
        // Choose source and target types from available types
        do {
            srcType = updatedAvailableTypes[Math.floor(Math.random() * updatedAvailableTypes.length)];
            tgtType = updatedAvailableTypes[Math.floor(Math.random() * updatedAvailableTypes.length)];
        } while (srcType === tgtType);
        
        // Choose specific buildings for source and target
        const srcBuilding = availableBuildings[srcType][Math.floor(Math.random() * availableBuildings[srcType].length)];
        const tgtBuilding = availableBuildings[tgtType][Math.floor(Math.random() * availableBuildings[tgtType].length)];
        
        // Optionally, pick a mid pipeline node type
        const midTypes = updatedAvailableTypes.filter(t => t !== srcType && t !== tgtType);
        midType = midTypes.length && Math.random() > 0.5 ? midTypes[Math.floor(Math.random() * midTypes.length)] : null;
        
        // Choose a specific mid building if we have a midType
        const midBuilding = midType ? availableBuildings[midType][Math.floor(Math.random() * availableBuildings[midType].length)] : null;
        
        // Create task object
        const task = {
            srcType,
            tgtType,
            midType,
            srcBuilding,
            tgtBuilding,
            midBuilding,
            completed: false,
            startTime: Date.now(),
            timeLimit: game.taskTimeLimit * 1000 // convert to ms
        };
        
        // Create a descriptive message for the task
        if (task.midType) {
            task.message = `Task: Connect ${BUILDING_DEFAULTS[srcType].name} to ${BUILDING_DEFAULTS[tgtType].name} using the ${BUILDING_DEFAULTS[task.midType].name}.`;
        } else {
            task.message = `Task: Connect ${BUILDING_DEFAULTS[srcType].name} to ${BUILDING_DEFAULTS[tgtType].name} directly.`;
        }
        
        return task;
    }
    
    function randomPipelineTask() {
        // For backward compatibility
        return generateTask().message;
    }

    // Function to check and progress through sandbox tutorial steps
    function checkSandboxProgress() {
      if (game.currentSandboxStep >= game.sandboxSteps.length) return;
      
      const currentStep = game.sandboxSteps[game.currentSandboxStep];
      
      // Check if the current step is complete based on its type
      let stepComplete = false;
      
      switch (currentStep.type) {
        case 'welcome':
          // Auto-advance after a few seconds
          if (!currentStep.shown) {
            currentStep.shown = true;
            setTimeout(() => {
              game.currentSandboxStep++;
            }, 5000);
          }
          break;
          
        case 'movement':
          // Complete when player moves
          if (game.player.x !== 400 || game.player.y !== 300) {
            stepComplete = true;
          }
          break;
          
        case 'connect':
          // Complete when terminal is opened
          if (terminalActive) {
            stepComplete = true;
          }
          break;
          
        case 'help':
          // Check if help command was used
          if (terminalActive && commandHistory.some(cmd => cmd.toLowerCase() === 'help')) {
            stepComplete = true;
          }
          break;
          
        case 'tools':
          // Check if list tools command was used
          if (terminalActive && commandHistory.some(cmd => cmd.toLowerCase() === 'list tools')) {
            stepComplete = true;
          }
          break;
          
        case 'send':
          // Check if send command was attempted
          if (terminalActive && commandHistory.some(cmd => cmd.toLowerCase().startsWith('send'))) {
            stepComplete = true;
          }
          break;
          
        case 'connection':
          // Check if a connection was made
          if (game.connections.length > 0) {
            stepComplete = true;
          }
          break;
          
        case 'complete':
          // This is the final step, no auto-advancement
          break;
      }
      
      // Advance to next step if current step is complete
      if (stepComplete) {
        game.currentSandboxStep++;
        
        // Show the next step's guidance
        if (game.currentSandboxStep < game.sandboxSteps.length) {
          const nextStep = game.sandboxSteps[game.currentSandboxStep];
          if (terminalActive) {
            typeLine(`>> ${nextStep.message}`, { className: 'system' });
          }
        }
      }
    }

    // Check if the current task is completed
    function checkTaskCompletion() {
        // Only check completion in challenge mode
        if (game.mode !== 'challenge' || !game.currentTask || game.currentTask.completed) return false;
        
        const { srcType, tgtType, midType } = game.currentTask;
        
        // Find buildings of the required types
        const srcBuildings = game.buildings.filter(b => b.type === srcType && b.active);
        const tgtBuildings = game.buildings.filter(b => b.type === tgtType && b.active);
        
        // If we need a mid node, check for it too
        if (midType) {
            const midBuildings = game.buildings.filter(b => b.type === midType && b.active);
            
            // Check if we have a connection from src to mid AND from mid to tgt
            const srcToMidConnected = game.connections.some(c => 
                (srcBuildings.includes(c.from) && midBuildings.includes(c.to)) ||
                (midBuildings.includes(c.from) && srcBuildings.includes(c.to)));
                
            const midToTgtConnected = game.connections.some(c => 
                (midBuildings.includes(c.from) && tgtBuildings.includes(c.to)) ||
                (tgtBuildings.includes(c.from) && midBuildings.includes(c.to)));
            
            if (srcToMidConnected && midToTgtConnected) {
                completeTask();
                return true;
            }
        } else {
            // Direct connection needed
            const connected = game.connections.some(c => 
                (srcBuildings.includes(c.from) && tgtBuildings.includes(c.to)) ||
                (tgtBuildings.includes(c.from) && srcBuildings.includes(c.to)));
            
            if (connected) {
                completeTask();
                return true;
            }
        }
        
        return false;
    }
    
    // Mark task as completed and give rewards
    function completeTask() {
        if (!game.currentTask || game.currentTask.completed) return;
        
        game.currentTask.completed = true;
        game.score += 100;
        game.completedTasks++;
        
        // Visual feedback
        const timeBonus = Math.max(0, Math.floor((game.currentTask.timeLimit - (Date.now() - game.currentTask.startTime)) / 1000));
        game.score += timeBonus;
        
        // Show completion message
        if (terminalActive) {
            typeLine(`>> Task completed! +100 points. Time bonus: +${timeBonus} points.`, { className: 'success' });
            typeLine(`>> Total score: ${game.score}. Tasks completed: ${game.completedTasks}`, { className: 'info' });
            setTimeout(() => {
                // Generate new task
                game.currentTask = generateTask();
                typeLine(`>> New ${game.currentTask.message}`, { className: 'system' });
            }, 2000);
        }
        
        // Celebration particles at player position
        for (let i = 0; i < 3; i++) {
            setTimeout(() => {
                game.particles.emit(game.player.x, game.player.y, colors.accent, 3, 20, [3, 8], 1.5);
            }, i * 300);
        }
    }
    let initialTaskShown = false;

    // Patch showTerminal to show the appropriate guidance based on game mode
    const originalShowTerminal = showTerminal;
    showTerminal = function(building) {
        originalShowTerminal(building);
        if (!initialTaskShown) {
            setTimeout(() => {
                // Show different content based on game mode
                if (game.mode === 'sandbox') {
                    // Show sandbox guidance
                    typeLine(game.sandboxSteps[0].message, { className: 'system', delay: 0 });
                    game.sandboxSteps[0].shown = true;
                } else {
                    // Show challenge task
                    typeLine(game.currentTask.message, { className: 'system', delay: 0 });
                    typeLine(`>> You have ${Math.floor(game.currentTask.timeLimit/1000)} seconds to complete this task.`, { className: 'info', delay: 0 });
                }
            }, 100);
            initialTaskShown = true;
        }
    };

    gameLoop(); // Start the main loop

  </script>
</body>
</html>